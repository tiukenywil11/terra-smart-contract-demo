"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const terra_js_1 = require("@terra-money/terra.js");
const config_1 = require("../config");
const deployment_1 = require("../lib/deployment");
const signer_1 = require("../lib/signer");
const fs = require("fs");
class Deploy extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Deploy);
        const connections = config_1.loadConnections(flags["config-path"]);
        const config = config_1.loadConfig(flags["config-path"]);
        const conf = config(flags.network, args.contract);
        // @ts-ignore
        const lcd = new terra_js_1.LCDClient(connections(flags.network));
        const signer = signer_1.getSigner({
            network: flags.network,
            signerId: flags.signer,
            keysPath: flags["keys-path"],
            lcd,
        });
        // Store sequence to manually increment after code is stored.
        const sequence = await signer.sequence();
        const codeId = await deployment_1.storeCode({
            conf,
            noRebuild: flags["no-rebuild"],
            contract: args.contract,
            signer,
            network: flags.network,
            refsPath: flags["refs-path"],
            lcd: lcd,
        });
        // pause for account sequence to update.
        await new Promise(r => setTimeout(r, 1000));
        const admin = flags["set-signer-as-admin"]
            ? signer.key.accAddress
            : flags["admin-address"];
        await deployment_1.instantiate({
            conf,
            signer,
            admin,
            sequence: 1 + sequence,
            contract: args.contract,
            codeId,
            network: flags.network,
            instanceId: flags["instance-id"],
            refsPath: flags["refs-path"],
            lcd: lcd,
        });
        fs.copyFileSync(flags["refs-path"], flags["frontend-refs-path"]);
    }
}
exports.default = Deploy;
Deploy.description = "Build wasm bytecode, store code on chain and instantiate.";
Deploy.flags = {
    "no-rebuild": command_1.flags.boolean({
        description: "deploy the wasm bytecode as is.",
        default: false,
    }),
    network: command_1.flags.string({ default: "localterra" }),
    "config-path": command_1.flags.string({ default: "./config.terrain.json" }),
    "refs-path": command_1.flags.string({ default: "./refs.terrain.json" }),
    "keys-path": command_1.flags.string({ default: "./keys.terrain.js" }),
    "instance-id": command_1.flags.string({ default: "default" }),
    signer: command_1.flags.string({ required: true }),
    "set-signer-as-admin": command_1.flags.boolean({
        description: "set signer (deployer) as admin to allow migration.",
        default: false,
    }),
    "admin-address": command_1.flags.string({
        description: "set custom address as contract admin to allow migration.",
    }),
    "frontend-refs-path": command_1.flags.string({
        default: "./frontend/src/refs.terrain.json",
    }),
};
Deploy.args = [{ name: "contract", required: true }];
