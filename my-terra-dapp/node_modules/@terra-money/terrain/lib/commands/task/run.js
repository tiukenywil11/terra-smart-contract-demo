"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.task = void 0;
const command_1 = require("@oclif/command");
const path = require("path");
const childProcess = require("child_process");
const cli_ux_1 = require("cli-ux");
const env_1 = require("../../lib/env");
exports.task = async (fn) => {
    try {
        await fn(env_1.getEnv(process.env.configPath || "", process.env.keysPath || "", process.env.refsPath || "", process.env.network || ""));
    }
    catch (err) {
        if (err instanceof Error) {
            cli_ux_1.cli.error(err);
        }
        if (typeof err === "string") {
            cli_ux_1.cli.error(err);
        }
        cli_ux_1.cli.error(`${err}`);
    }
};
class Run extends command_1.Command {
    async run() {
        const { args, flags } = this.parse(Run);
        const fromCwd = (p) => path.join(process.cwd(), p);
        runScript(fromCwd(`tasks/${args.task}.js`), {
            configPath: fromCwd(flags["config-path"]),
            keysPath: fromCwd(flags["keys-path"]),
            refsPath: fromCwd(flags["refs-path"]),
            network: flags.network,
        }, (err) => {
            if (err)
                throw err;
        });
    }
}
exports.default = Run;
Run.description = "run predefined task";
Run.flags = {
    network: command_1.flags.string({ default: "localterra" }),
    "config-path": command_1.flags.string({ default: "config.terrain.json" }),
    "refs-path": command_1.flags.string({ default: "refs.terrain.json" }),
    "keys-path": command_1.flags.string({ default: "keys.terrain.js" }),
};
Run.args = [{ name: "task" }];
function runScript(scriptPath, env, callback) {
    // keep track of whether callback has been invoked to prevent multiple invocations
    let invoked = false;
    const cProcess = childProcess.fork(scriptPath, { env });
    // listen for errors as they may prevent the exit event from firing
    cProcess.on("error", function (err) {
        if (invoked)
            return;
        invoked = true;
        callback(err);
    });
    // execute the callback once the process has finished running
    cProcess.on("exit", function (code) {
        if (invoked)
            return;
        invoked = true;
        const err = code === 0 ? undefined : new Error("exit code " + code);
        callback(err);
    });
}
